"""
implement a friendlier doc server
"""
__author__ = 'gabi'

import mimetools
import threading
from pydoc import *

import BaseHTTPServer
from SocketServer import ThreadingMixIn

# Patch up mimetools.Message so it doesn't break if rfc822 is reloaded.
class Message(mimetools.Message):
    def __init__(self, fp, seekable=1):
        Message = self.__class__
        Message.__bases__[0].__bases__[0].__init__(self, fp, seekable)
        self.encodingheader = self.getheader('content-transfer-encoding')
        self.typeheader = self.getheader('content-type')
        self.parsetype()
        self.parseplist()

class DocHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    def send_document(self, title, contents):
        try:
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.end_headers()
            self.wfile.write(html.page(title, contents))
        except IOError: pass

    def do_GET(self):
        path = self.path
        if path[-5:] == '.html': path = path[:-5]
        if path[:1] == '/': path = path[1:]
        if path and path != '.':
            try:
                obj = locate(path, forceload=1)
            except ErrorDuringImport, value:
                self.send_document(path, html.escape(str(value)))
                return
            if obj:
                self.send_document(describe(obj), html.document(obj, path))
            else:
                self.send_document(path,
                    'no Python documentation found for %s' % repr(path))
        else:
            heading = html.heading(
                '<big><big><strong>Python: Index of Modules</strong></big></big>',
                '#ffffff', '#7799ee')
            def bltinlink(name):
                return '<a href="%s.html">%s</a>' % (name, name)
            names = filter(lambda x: x != '__main__',
                sys.builtin_module_names)
            contents = html.multicolumn(names, bltinlink)
            indices = ['<p>' + html.bigsection(
                'Built-in Modules', '#ffffff', '#ee77aa', contents)]

            seen = {}
            for dir in sys.path:
                indices.append(html.index(dir, seen))
            contents = heading + join(indices) + '''<p align=right>
<font color="#909090" face="helvetica, arial"><strong>
pydoc</strong> by Ka-Ping Yee &lt;ping@lfw.org&gt;</font>'''
            self.send_document('Index of Modules', contents)

    def log_message(self, *args): pass

class DocServer( threading.Thread, ThreadingMixIn, BaseHTTPServer.HTTPServer):

    base = BaseHTTPServer.HTTPServer
    handler = DocHandler
    MessageClass = Message

    def __init__(self, port, callback=None, completer=None):
        host = 'localhost'
        self.address = (host, port)
        self.url = 'http://%s:%d/' % (host, port)
        self.callback = callback
        self.completer = completer
        self.base.__init__(self, self.address, self.handler)
        threading.Thread.__init__(self, name='xydoc_server')

    def run(self):
        import select
        self.quit = False
        while not self.quit:
            rd, wr, ex = select.select([self.socket.fileno()], [], [], 1)
            if rd: self.handle_request()

        if self.completer:
            self.completer()

    def server_activate(self):
        self.base.server_activate(self)
        if self.callback:
            self.callback(self)

    def stop_serve(self):
        self.quit = True
        self.join()

